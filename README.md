# Шаблоны
В этом разделе мы будем рассматривать еще один подход к программированию или стиль программирования это обобщенное программирования. Так что такое обобщенное программирование и зачем оно нужно. Чтобы было более ясно о чем речь, обобщенное программирование можно сравнить с формулой. Формула есть общее понятие, она описывает суть, общность. Например получение площи квадрата, сама формула это общее описание, а вот определенные коэфиценты это ее реазилация. Но обобщеность имеет также некое ограничение, например коэфициент принадлежит только такому диапазону чисел, точно также и с обобщеностью на них тоже может накладываться ограничение.
В С++ обощенность выраженна понятием шаблона. Все понимаем что шаблон это некий каркас, или некая модель, т.е по шаблону мы создаем уже конкретную модель. Почти похожа аналогия с классами и объектом, где класс это чертеж, а вот объект это реализация этого чертижа.
Так а зачем такая обобщеность нужна в программировании? Мы уже применяли обощенность, добавляя в функцию сортировки, некий компаратор, смысл которого решить как будет у нас выполняться сортировка. Т.е. алгоритм знает как получить данные, а компаратор знает как сравнивать эти данные.
**Шаблон это простая кодо генерация** Идея шаблона сгенерировать конкретный участок кода! И проблема шаблонов как мы будем дальше видеть это **раздувания кода**
Но больше их применение это в динамических структурах. Ну сейчас мы поймем это.  
Забегая вперед мы в этом разделе рассмотрим только маленький кусочер шаблонов, так как тема шаблонов она требует больше времени, когда идет дело с продвинутой работой шаблонов.
В С++ выделяют шаблоны класса и  шаблоны функции.
## Макросы
При чем тут макросы. А при том. Выше я сказал что шаблон это простая генерация кода. А мы знаем что макрос это подстановка имени макроса его содержимым на этапе препроцесинга.
Давайте вернемся к нашему примеру стека. У него есть огромный недостаток, а именно в него можно сохранять только значение `int`. А мы знаем что стек это некая общая структура которая может работать(правильней сказать хранить) как с целыми, так с вещественными, так и пользовательские типы. Мы знаем что макрос это обычная подстановка текста. Ок давайте сделаем макрос которое в качестве параметров принимает тип имя этого стека.

Сам макрос
```cpp
#pragma once
#include "common_type.hpp"

#define STACK(Name, Type) \
class Stack##Name { \
  public: \
   Pair pop() { \
     Pair res {false, "Stack empty"}; \
     if (nullptr == array) { \
       res.msg = "Stack is not allocated"; \
       return res; \
     } \
     if (current_position == -1) { \
       return res; \
     } \
     --current_position; \
     res = {true, "Success"}; \
     return res; \
   } \
   Value top() const { \
     Value res {false, 0}; \
     if (nullptr == array) { \
       return res; \
     } \
     if (current_position == -1) { \
       return res; \
     } \
     res = {true, array[current_position]}; \
     return res; \
   } \
   Pair push(Type value) { \
     Pair res {false, ""}; \
     if (nullptr == array) { \
       res.msg = "Stack is not allocated"; \
       return res; \
     } \
     if (current_position == SIZE_STACK) { \
       res.msg = "Satck is full"; \
       return res; \
     } \
     array[++current_position] = value; \
     res.status = true; \
     res.msg = "Success add to stack"; \
     return res; \
   } \
   Stack##Name(int size) \
      : SIZE_STACK(size) { \
     if (SIZE_STACK > 0) { \
       array = new Type [SIZE_STACK]{}; \
     } \
   } \
  ~Stack##Name() { \
    if (array != nullptr) { \
      delete [] array; \
    } \
  } \
  private: \
   Type* array = nullptr; \
   int current_position = -1; \
   int SIZE_STACK = 5; \
};

```

Просто дичь! Т.е. видим что мы передаем имя нашего класса, и тип массива. Символ в `##` есть просто простая конкатенация строк на этапе препроцесинга. Также есть проблема в том что макрос это на самом деле однострочный оператор, и нам приходиться склеивать таким образом строки как макроса чтобы определить его как одну строку. Еще другая проблема что такой макрос мы не сможем определить раздельную компиляцию(отделив заголовочный файл от файла реализации)
Ок, и его использование в main
```cpp
#include <iostream>

#include "template_macros.hpp"

int main(int argc, char const *argv[]) {
  STACK(Int, int)
  StackInt st {10};

  STACK(Float, float)
  StackFloat st_new {10};

  return 0;
}

```
Видно что мы указываем имя макроса, которое будет заменено на строчку макроса которую мы определили в заголовочном файле. В итоге в первом случае нам компилятор подставит вместо макроса `STACK(Int, int)` объявление класса `StackInt`, а `Type` заменит на `int`. То же и касаеться для `float`.
Но самая большая проблема макроса это **проблема с раскрытием макроса**, т.е. макросы не есть типо безопасными. А именно сначало препроцессор ввиде строчки раскроет макрос, а потом только компилятор начнем смотреть в него синтаксическую корестность. И мы будем получать ошибки немного сложные в описании, и строчки которые соответсвуют строчкам раскрытия макроса, а не его описания.

##Шаблоны класса.
Макросы, это был хороший и популярный механизм, более мение близкий, к обобщеному программированию. Шаблоны как раз и призваны решить эти недостатки макросов. Механизм шаблонов похож на макросы, только:
1. Это конструкции языка, со всеми синтаксическими последствиями
2. Ошибки вы получаете уже на этапе компиляции, а не препроцессинга, т.е. получаете внеменяемую(читаемую) ошибку, строку, в коде.

Как было сказано проблема шаблонов, да и макросов, это раздувание кода. Ок давайте перепишем наш стек на шаблонный.
```cpp
#pragma once
#include "common_type.hpp"

template <class /*typename*/ T>
class Stack {
 public:
  Pair push(T value) {
    Pair res {false, ""};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }

    if (current_position == SIZE_STACK) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

  Pair pop() {
    Pair res {false, "Stack empty"};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }
    if (current_position == -1) {
      return res;
    }
    --current_position;
    res = {true, "Success"};
    return res;
  }

  Value top() const {
    Value res {false, 0};
    if (nullptr == array) {
      return res;
    }

    if (current_position == -1) {
      return res;
    }
    res = {true, array[current_position]};
    return res;
  }
  int GetMaxStackSize() {
    return SIZE_STACK;
  }

  int GetCurrentPosition() const {
    return current_position;
  }

  Stack(int size)
     : SIZE_STACK(size) {
    if (SIZE_STACK > 0) {
      array = new T [SIZE_STACK]{};
    }
  }

  Stack(const Stack& st)
    : Stack(st.SIZE_STACK) {
  }

  Stack() = delete;

  ~Stack() {
    if (array != nullptr) {
      delete [] array;
    }
  }

  Stack& operator=(const Stack& st) {
    if (this == &st) {
      return *this;
    }
 
    if (array != nullptr) {
      delete [] array;
    }
    current_position = st.current_position;
    SIZE_STACK = st.SIZE_STACK;
    array = new T[SIZE_STACK] {};

    for (decltype(SIZE_STACK) i = 0; i < SIZE_STACK; ++i) {
      array[i] = array[i + 1];
    }
    return *this;
  }
 private:
  T* array = nullptr;
  int current_position = -1;
  int SIZE_STACK = 5;
};

```
Как видно из реализации ничего не поменялось как с привычным нам объявлением, только добавилось слово `template` `class`. По порядку, `template`вы говорите компилятору что вы намереваетесь объявить шаблон. Дальше в угловых скобочках вы передаете тип(информацию для компиялтора что делать с этим классом) `<class T>`. Где `T` это имя типа которое  будет передваться при создании шаблона, на самом деле имя может быть любым это просто общее соглашение. ШАблон чем то похож на функцию, смысл которой работать с данными, т.е. данные передавались как параметр. Шаблоны они работают с типами.
Но при таком коде компилятор если мы добавим заголовочный файл, то компилятор может посмотреть только не которые общие синтаксические ошибки, иногда даже может и с оптимизировать и вообще этот шаблон не рассмартивать(бывает и такое), но полный анализ компилятор начнет делать когда мы создадим экземпляр такого шаблона.
```cpp
#include <iostream>

//#include "template_macros.hpp"
#include "template_class.hpp"

int main(int argc, char const *argv[]) {
  Stack<int> st{20};
  std::cout << st.GetMaxStackSize() << std::endl;

  Stack<float> st_float{20};
  std::cout << st.GetMaxStackSize() << std::endl;

  return 0;
}

```

Как видим с примера выше, наш код кардинально отличаеться от макроса, он есть частью привычной нам языковой конструкцией. Тут мы создаем(инстанцируем) два класса Stack c типами int и double.
Поговорим про создание. Не говорят создание шаблона. Говрят инстанцирование. В строке `Stack<int> st{20};` много интерсного.
1. При таком объявлении компилятор смотрит так есть у меня в системе такой интстанцирование (готовый уже клласс) шаблон класса с именем Stack. Ок, нет, но у меня есть шаблон по которому я могу это создать. И тут **важное** что компилятор до этой строки компилировал наш шаблон, как общий не в даваясь в конкретный тип. А вот после он уже инстанцировал конкретный класс с типом который мы передали в качестве параметра, и тут компилятор делает еще одну проверку мол типа а коректные конструкции, т.е. можна их ли применять, к этому типу передаваемого в наш класс. Т.е. синтаксически идет проверка уже нашого передаваемого типа для шаблона.

2. После уже синтаксического анализа типа и шаблона, компиялтор создает и иницализирует объект этого класса.

3. А если мы объявляем другую переменную этого типа, например `Stack<int> st_next{100};`, то компилятор увидет что уже есть экземпляр, установленный(грубое слово), шаблона и не будет больше гененрировать такой шаблон, а просто создаст перменную.

Т.е. вывод что инстанцирование, т.е. создание полного класса, и его анализ происходит только один раз.

Как я и говорил, что тип это подобие данных передаваемых в функцию, и также как в данных в шаблоне класса можно указывать дефолтный тип. Суть такого подхода такой же как и обычными данными, возможность опускать некоторые типы.
Типов в шаблоне можно передвать много, все они передаються через запятую, но только имя индетификатора типа, должно быть разное, а вот тип при создании шаблона, может повторяться.
Давайте в наш класс добавим дефолтный нам тип это тип `int`.
```cpp
template <class /*typename*/ T = int>
```
Как видим поменялась, только одна строка и все, в самом теле шаблона никаких изменений делать ненадо. Тут также как и по аналогии с даными, указали что если опустить тип при создании шаблона, то дефолтным типом будет `int`
Ну правда немного отличаеться вызов.
```cpp
  Stack<> st{20};
  std::cout << st.GetMaxStackSize() << std::endl;
```
Как видим нам всеравно надо указывать угловые скобочки, тем самым мы опускаем имя типа.

В шаблоны кроме типа можно передавать и значение. Давайте лучше пример. У нас есть динамический массив, но мы знаем что динамика ведет за собой  кучу проблем, а именно нам надо выделить эту память, освободить ее, да и плюс реализовать сейвед операции по работе с указателями, как конструктор копирования и т.д. Ну проблема стека остаеться, но иногда нам не нужно выделять память под стек, если размер его небольшой. Так как нам так сделать чтобы нам на статике, т.е. в стеке выделить память. Вот для этих целей и используют интегральные значения в качестве параметра шаблона.
```cpp
#pragma once
#include "common_type.hpp"

template <class /*typename*/ T, unsigned SIZE>
class Stack {
 public:
  Pair push(T value) {
    Pair res {false, ""};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }

    if (current_position == SIZE) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

  Pair pop() {
    Pair res {false, "Stack empty"};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }
    if (current_position == -1) {
      return res;
    }
    --current_position;
    res = {true, "Success"};
    return res;
  }

  Value top() const {
    Value res {false, 0};
    if (nullptr == array) {
      return res;
    }

    if (current_position == -1) {
      return res;
    }
    res = {true, array[current_position]};
    return res;
  }
  int GetMaxStackSize() {
    return SIZE;
  }

  int GetCurrentPosition() const {
    return current_position;
  }
 private:
  T array[SIZE];
  int current_position = -1;
};

```

Смотрит что произошло с нашим кодом, у него удалилось много чего, динамика, и за ними не нужные конструкторы, и т.д. Это наш класс, который мы разрабатывали в самом начале. Но он даже еще лучше чем начальный.
1. Он может работать с разными типами
2. Что самое важное мы решили проблему с определением параметра для размера стека.

Темплейты рулят

Ок, скаже вы а если мне надо решить проблему, когда у меня будет большой размер стека. И тут нам на помощь приходит такое понятие как специализация. Сколько терминологии не интресной. Другим словом, мы должны сказать компилятору, что для такого типа наш класс будет работать по другому. Это аналогия как с перегрузкой только для класса.
Давайте напишим
```cpp

/*
Template specialization
*/
#pragma once
#include "common_type.hpp"

template <class /*typename*/ T, unsigned SIZE>
class Stack <T*, SIZE> {
 public:
  Pair push(T value) {
    Pair res {false, ""};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }

    if (current_position == SIZE) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

  Pair pop() {
    Pair res {false, "Stack empty"};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }
    if (current_position == -1) {
      return res;
    }
    --current_position;
    res = {true, "Success"};
    return res;
  }

  Value top() const {
    Value res {false, 0};
    if (nullptr == array) {
      return res;
    }

    if (current_position == -1) {
      return res;
    }
    res = {true, array[current_position]};
    return res;
  }
  int GetMaxStackSize() {
    return SIZE;
  }

  int GetCurrentPosition() const {
    return current_position;
  }

  Stack() {
    std::cout << "Heap version" << std::endl;
    if (SIZE > 0) {
      array = new T [SIZE]{};
    }
  }

  Stack(const Stack& st) = delete;

  ~Stack() {
    if (array != nullptr) {
      delete [] array;
    }
  }

  Stack& operator=(const Stack& st) = delete;
 private:
  T* array = nullptr;
  int current_position = -1;
};
```

Как видим специализация, отличаеться от оригинального нашего класса, а именно добавлением после имени класса угловых скобочек, в которых мы указываем это класс шаблона отличаеться от базового если вы будете создавать этот класс для укзателей. Все просто
Круто у нас есть класс который может работать на стеке и на куче.
Как бы все что можно сказать для базового понимания шаблонов. 